This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-01-20T04:38:19.425Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
assets/
  css/
    breadcrumbs.css
helpers/
  breadcrumb_helper.rb
  highlight_helper.rb
migrate/
  001_create_users.rb
  002_create_plays_acts_scenes_speeches_lines.rb
  003_create_interpretations.rb
  004_create_interpretation_votes.rb
  008_create_achievements.rb
routes/
  admin.rb
  auth.rb
  interpretations.rb
  plays.rb
  profiles.rb
  search.rb
views/
  admin/
    plays/
      index.erb
    index.erb
  auth/
    login.erb
    register.erb
  interpretations/
    _video_preview.erb
    new.erb
    show.erb
  plays/
    index.erb
    show_play.erb
    show_scene.erb
    show_speech.erb
  profiles/
    show.erb
  search/
    results.erb
  index.erb
  layout.erb
config.ru
db.rb
Gemfile
Gemfile.lock
models.rb
pagy.rb
Rakefile
shakespeare_app.rb

================================================================
Files
================================================================

================
File: assets/css/breadcrumbs.css
================
.breadcrumbs {
    padding: 1rem 0;
    margin-bottom: 1rem;
  }
  
  .breadcrumbs-list {
    display: flex;
    flex-wrap: wrap;
    list-style: none;
    padding: 0;
    margin: 0;
  }
  
  .breadcrumb-item {
    font-size: 0.875rem;
    color: #666;
  }
  
  .breadcrumb-item.current {
    color: #333;
    font-weight: 500;
  }
  
  .breadcrumb-item a {
    color: #0066cc;
    text-decoration: none;
  }
  
  .breadcrumb-item a:hover {
    text-decoration: underline;
  }

================
File: helpers/breadcrumb_helper.rb
================
module BreadcrumbHelper
    def breadcrumb_trail
      links = []
      links << ['Home', '/']
      
      case request.path_info
      when /^\/plays\/(\d+)\/acts\/(\d+)\/scenes\/(\d+)\/speeches\/(\d+)/
        play = Play[$1]
        act = Act[$2]
        scene = Scene[$3]
        speech = Speech[$4]
        
        links << ['Plays', '/plays']
        links << [play.title, "/plays/#{play.id}"]
        links << ["Act #{act.act_number}", "/plays/#{play.id}/acts/#{act.id}"]
        links << ["Scene #{scene.scene_number}", "/plays/#{play.id}/acts/#{act.id}/scenes/#{scene.id}"]
        links << ["#{speech.speaker_name}'s Speech", "/plays/#{play.id}/acts/#{act.id}/scenes/#{scene.id}/speeches/#{speech.id}"]
      when /^\/plays\/(\d+)\/acts\/(\d+)\/scenes\/(\d+)/
        play = Play[$1]
        act = Act[$2]
        scene = Scene[$3]
        
        links << ['Plays', '/plays']
        links << [play.title, "/plays/#{play.id}"]
        links << ["Act #{act.act_number}", "/plays/#{play.id}/acts/#{act.id}"]
        links << ["Scene #{scene.scene_number}", ""]
      when /^\/plays\/(\d+)\/acts\/(\d+)/
        play = Play[$1]
        act = Act[$2]
        
        links << ['Plays', '/plays']
        links << [play.title, "/plays/#{play.id}"]
        links << ["Act #{act.act_number}", ""]
      when /^\/plays\/(\d+)/
        play = Play[$1]
        links << ['Plays', '/plays']
        links << [play.title, ""]
      when /^\/plays/
        links << ['Plays', ""]
      end
      
      render_breadcrumbs(links)
    end
    
    private
    
    def render_breadcrumbs(links)
      <<-HTML
      <nav aria-label="Breadcrumb navigation" class="breadcrumbs">
        <ol role="list" class="breadcrumbs-list">
          #{links.map.with_index do |(text, url), index|
            is_last = index == links.length - 1
            <<-LI
            <li class="breadcrumb-item#{' current' if is_last}" 
                #{is_last ? 'aria-current="page"' : ''}>
              #{url.empty? ? text : "<a href=\"#{url}\">#{text}</a>"}
              #{is_last ? '' : '<span aria-hidden="true"> › </span>'}
            </li>
            LI
          end.join}
        </ol>
      </nav>
      HTML
    end
  end

================
File: helpers/highlight_helper.rb
================
module HighlightHelper
  def highlight(text, term)
    regex = Regexp.new("(?i)(#{Regexp.escape(term)})")
    # Escape the entire text to prevent XSS, then insert <mark> tags for the term
    escaped_text = ERB::Util.html_escape(text)
    highlighted_text = escaped_text.gsub(regex, '<mark>\1</mark>')
    highlighted_text
  end
end

================
File: migrate/001_create_users.rb
================
Sequel.migration do
    change do
      create_table(:users) do
        primary_key :id
        String :email, null: false, unique: true
        String :password_digest, text: true  # storing a hashed password
        String :display_name
        Boolean :is_admin, default: false
        DateTime :created_at, default: Sequel::CURRENT_TIMESTAMP
        DateTime :updated_at, default: Sequel::CURRENT_TIMESTAMP
      end
    end
  end

================
File: migrate/002_create_plays_acts_scenes_speeches_lines.rb
================
Sequel.migration do
    change do
      create_table(:plays) do
        primary_key :id
        String :title, null: false
        String :author
        Text   :notes
        DateTime :created_at, default: Sequel::CURRENT_TIMESTAMP
        DateTime :updated_at, default: Sequel::CURRENT_TIMESTAMP
      end
  
      create_table(:acts) do
        primary_key :id
        foreign_key :play_id, :plays, on_delete: :cascade
        Integer :act_number, null: false
        String :description
        DateTime :created_at, default: Sequel::CURRENT_TIMESTAMP
        DateTime :updated_at, default: Sequel::CURRENT_TIMESTAMP
      end
  
      create_table(:scenes) do
        primary_key :id
        foreign_key :act_id, :acts, on_delete: :cascade
        Integer :scene_number, null: false
        String :description
        DateTime :created_at, default: Sequel::CURRENT_TIMESTAMP
        DateTime :updated_at, default: Sequel::CURRENT_TIMESTAMP
      end
  
      create_table(:speeches) do
        primary_key :id
        foreign_key :scene_id, :scenes, on_delete: :cascade
        String :speaker_name
        Integer :order_in_scene
        Text   :notes
        DateTime :created_at, default: Sequel::CURRENT_TIMESTAMP
        DateTime :updated_at, default: Sequel::CURRENT_TIMESTAMP
      end
  
      create_table(:speech_lines) do
        primary_key :id
        foreign_key :speech_id, :speeches, on_delete: :cascade
        Integer :start_line_number
        Integer :end_line_number
        Text   :text, null: false
        DateTime :created_at, default: Sequel::CURRENT_TIMESTAMP
        DateTime :updated_at, default: Sequel::CURRENT_TIMESTAMP
      end
    end
  end

================
File: migrate/003_create_interpretations.rb
================
Sequel.migration do
    change do
      create_table(:interpretations) do
        primary_key :id
        foreign_key :user_id, :users, on_delete: :cascade
        foreign_key :speech_line_id, :speech_lines, on_delete: :cascade

        add_index :interpretations, :user_id
        add_index :interpretations, :speech_line_id
  
        # We'll store a YouTube URL
        String :youtube_url, null: false
        Text :description  # optional user-provided note
        DateTime :created_at, default: Sequel::CURRENT_TIMESTAMP
        DateTime :updated_at, default: Sequel::CURRENT_TIMESTAMP
      end
    end
  end

================
File: migrate/004_create_interpretation_votes.rb
================
Sequel.migration do
  change do
    create_table(:interpretation_votes) do
      primary_key :id
      foreign_key :user_id, :users, on_delete: :cascade
      foreign_key :interpretation_id, :interpretations, on_delete: :cascade
      String :vote_type, null: false
      DateTime :created_at, default: Sequel::CURRENT_TIMESTAMP
    end

    # Add a check constraint to ensure vote_type is valid
    alter_table(:interpretation_votes) do
      add_constraint(:vote_type_constraint, "vote_type IN ('upvote', 'downvote', 'inappropriate')")
      add_unique [:user_id, :interpretation_id], name: :unique_user_interpretation_vote
    end
  end
end

================
File: migrate/008_create_achievements.rb
================
Sequel.migration do
    change do
      create_table(:achievements) do
        primary_key :id
        String :name, null: false
        String :description
        String :badge_icon  # CSS class for the badge icon
        DateTime :created_at, default: Sequel::CURRENT_TIMESTAMP
      end
  
      create_table(:user_achievements) do
        primary_key :id
        foreign_key :user_id, :users, on_delete: :cascade
        foreign_key :achievement_id, :achievements, on_delete: :cascade
        DateTime :earned_at, default: Sequel::CURRENT_TIMESTAMP
        index [:user_id, :achievement_id], unique: true
      end
    end
  end

================
File: routes/admin.rb
================
module AdminRoutes
  def self.load(r)
    r.hash_branch "admin" do |r|
      # Authentication & Authorization
      require_login!
      unless current_user&.is_admin
        flash["error"] = "Admin access required"
        r.redirect("/")
      end

      r.on "plays" do
        # GET /admin/plays - List all plays
        r.get do
          @plays = Play.order(Sequel.asc(:title)).all
          view("admin/plays/index")
        end

        # Play creation routes
        r.is "new" do
          r.get do
            view("admin/plays/new_play")
          end

          # POST /admin/plays - Create play
          r.post do
            begin
              title = r.params["title"]&.strip
              author = r.params["author"]&.strip
              notes = r.params["notes"]&.strip

              play = Play.new(
                title: title,
                author: author,
                notes: notes
              )

              if play.valid? && play.save
                flash["notice"] = "Play '#{play.title}' created successfully."
                r.redirect("/admin/plays")
              else
                flash["error"] = "Error creating play: #{play.errors.full_messages.join(", ")}"
                r.redirect("/admin/plays/new")
              end
            rescue Sequel::Error => e
              flash["error"] = "Database error: #{e.message}"
              r.redirect("/admin/plays/new")
            end
          end
        end

        # Routes for specific play
        r.on Integer do |play_id|
          begin
            play = Play[play_id] or r.halt(404, "Play not found")

            # GET /admin/plays/:play_id - Show play details
            r.get do
              @play = play
              @acts = play.acts_dataset.order(:act_number).all
              view("admin/plays/show_play")
            end

            # Routes for editing play
            r.on "edit" do
              r.get do
                @play = play
                view("admin/plays/edit_play")
              end

              r.post do
                begin
                  title = r.params["title"]&.strip
                  author = r.params["author"]&.strip
                  notes = r.params["notes"]&.strip

                  if play.update(
                    title: title,
                    author: author,
                    notes: notes
                  )
                    flash["notice"] = "Play updated successfully."
                    r.redirect("/admin/plays/#{play_id}")
                  else
                    flash["error"] = "Error updating play: #{play.errors.full_messages.join(", ")}"
                    r.redirect("/admin/plays/#{play_id}/edit")
                  end
                rescue Sequel::Error => e
                  flash["error"] = "Database error: #{e.message}"
                  r.redirect("/admin/plays/#{play_id}/edit")
                end
              end
            end

            # Routes for deleting play
            r.on "delete" do
              r.post do
                begin
                  play_title = play.title
                  DB.transaction do
                    play.destroy
                  end
                  flash["notice"] = "Play '#{play_title}' deleted successfully."
                  r.redirect("/admin/plays")
                rescue Sequel::Error => e
                  flash["error"] = "Error deleting play: #{e.message}"
                  r.redirect("/admin/plays/#{play_id}")
                end
              end
            end

            # Act management routes
            r.on "acts" do
              # Create new act
              r.post "new" do
                begin
                  act_number = r.params["act_number"]&.to_i
                  description = r.params["description"]&.strip

                  act = Act.new(
                    play_id: play.id,
                    act_number: act_number,
                    description: description
                  )

                  if act.valid? && act.save
                    flash["notice"] = "Act #{act.act_number} created successfully."
                  else
                    flash["error"] = "Error creating act: #{act.errors.full_messages.join(", ")}"
                  end
                  r.redirect("/admin/plays/#{play_id}")
                rescue Sequel::Error => e
                  flash["error"] = "Database error: #{e.message}"
                  r.redirect("/admin/plays/#{play_id}")
                end
              end

              # Edit act
              r.on Integer do |act_id|
                act = Act[act_id] or r.halt(404, "Act not found")
                
                r.post "edit" do
                  begin
                    act_number = r.params["act_number"]&.to_i
                    description = r.params["description"]&.strip

                    if act.update(
                      act_number: act_number,
                      description: description
                    )
                      flash["notice"] = "Act updated successfully."
                    else
                      flash["error"] = "Error updating act: #{act.errors.full_messages.join(", ")}"
                    end
                    r.redirect("/admin/plays/#{play_id}")
                  rescue Sequel::Error => e
                    flash["error"] = "Database error: #{e.message}"
                    r.redirect("/admin/plays/#{play_id}")
                  end
                end

                # Delete act
                r.post "delete" do
                  begin
                    DB.transaction do
                      act.destroy
                    end
                    flash["notice"] = "Act #{act.act_number} deleted successfully."
                    r.redirect("/admin/plays/#{play_id}")
                  rescue Sequel::Error => e
                    flash["error"] = "Error deleting act: #{e.message}"
                    r.redirect("/admin/plays/#{play_id}")
                  end
                end
              end
            end
          rescue Sequel::Error => e
            flash["error"] = "Database error: #{e.message}"
            r.redirect("/admin/plays")
          end
        end
      end
      
      # Admin Dashboard
      r.is do
        r.get do
          @all_users = User.order(Sequel.desc(:created_at)).all
          @all_interps = Interpretation.order(Sequel.desc(:created_at)).limit(50).all
          @stats = {
            total_users: User.count,
            total_plays: Play.count,
            total_interpretations: Interpretation.count,
            recent_interpretations: Interpretation.where { created_at > Time.now - 7*24*60*60 }.count
          }
          view("admin/index")
        end
      end
    end
  end
end

================
File: routes/auth.rb
================
module AuthRoutes
  def self.load(r)
    r.on "auth" do
      # Rate limiting setup
      THROTTLE_LIMIT = 5
      THROTTLE_PERIOD = 900 # 15 minutes in seconds
      
      r.on "login" do
        # GET /auth/login
        r.get do
          view("auth/login")
        end

        # POST /auth/login
        r.post do
          email = r.params["email"]&.strip&.downcase
          
          # Rate limiting check
          attempts = r.session["login_attempts"] || {}
          attempts = attempts.select { |_, time| time > Time.now.to_i - THROTTLE_PERIOD }
          
          if attempts.size >= THROTTLE_LIMIT
            flash["error"] = "Too many login attempts. Please try again in 15 minutes."
            r.redirect("/auth/login")
            return
          end

          user = User[email: email]
          if user && user.valid_password?(r.params["password"])
            # Successful login
            session.clear # Clear any old session data
            session[:user_id] = user.id
            session[:created_at] = Time.now.to_i
            
            # Update last login timestamp
            user.update(last_login_at: Sequel::CURRENT_TIMESTAMP)
            
            flash["notice"] = "Welcome back, #{user.display_name || user.email}!"
            r.redirect(session[:return_to] || "/")
            session[:return_to] = nil
          else
            # Failed login attempt
            attempts[Time.now.to_i] = Time.now.to_i
            session["login_attempts"] = attempts
            
            flash["error"] = "Invalid email or password"
            r.redirect("/auth/login")
          end
        end
      end

      r.on "logout" do
        # POST /auth/logout (changed from GET for security)
        r.post do
          session.clear
          flash["notice"] = "Logged out successfully."
          r.redirect("/")
        end
      end

      r.on "register" do
        # GET /auth/register
        r.get do
          view("auth/register")
        end

        # POST /auth/register
        r.post do
          email = r.params["email"]&.strip&.downcase
          pass = r.params["password"]
          pass_confirm = r.params["password_confirmation"]
          disp = r.params["display_name"]&.strip

          errors = []
          errors << "Email is required" if email.blank?
          errors << "Display name is required" if disp.blank?
          errors << "Password is required" if pass.blank?
          errors << "Passwords don't match" if pass != pass_confirm
          errors << "Password must be at least 8 characters" if pass && pass.length < 8
          
          if errors.any?
            flash["error"] = errors.join(", ")
            r.redirect("/auth/register")
            return
          end

          user = User.new(
            email: email,
            display_name: disp,
            email_verified: false
          )
          user.password = pass

          if user.save
            # Send verification email (implemented elsewhere)
            UserMailer.verification_email(user)
            
            session[:user_id] = user.id
            session[:created_at] = Time.now.to_i
            flash["notice"] = "Welcome! Please check your email to verify your account."
            r.redirect("/")
          else
            flash["error"] = user.errors.full_messages.join(", ")
            r.redirect("/auth/register")
          end
        end
      end

      r.on "profile" do
        r.is do
          # Must be logged in to access profile
          unless current_user
            session[:return_to] = "/auth/profile"
            flash["notice"] = "Please log in to access your profile"
            r.redirect("/auth/login")
          end

          # GET /auth/profile
          r.get do
            view("auth/profile")
          end

          # POST /auth/profile
          r.post do
            if current_user.update(
              display_name: r.params["display_name"]&.strip,
              email: r.params["email"]&.strip&.downcase,
              bio: r.params["bio"]&.strip
            )
              flash["notice"] = "Profile updated successfully"
            else
              flash["error"] = current_user.errors.full_messages.join(", ")
            end
            r.redirect("/auth/profile")
          end
        end

        r.on "change_password" do
          # POST /auth/profile/change_password
          r.post do
            unless current_user.valid_password?(r.params["current_password"])
              flash["error"] = "Current password is incorrect"
              r.redirect("/auth/profile")
              return
            end

            new_pass = r.params["new_password"]
            if new_pass.length < 8
              flash["error"] = "New password must be at least 8 characters"
              r.redirect("/auth/profile")
              return
            end

            if new_pass != r.params["new_password_confirmation"]
              flash["error"] = "New passwords don't match"
              r.redirect("/auth/profile")
              return
            end

            current_user.password = new_pass
            if current_user.save
              flash["notice"] = "Password updated successfully"
              # Force re-login with new password
              session.clear
              r.redirect("/auth/login")
            else
              flash["error"] = "Error updating password"
              r.redirect("/auth/profile")
            end
          end
        end
      end

      r.on "verify" do
        # GET /auth/verify/:token
        r.get String do |token|
          user = User.find(verification_token: token)
          if user && !user.email_verified?
            user.update(
              email_verified: true,
              verification_token: nil,
              verified_at: Sequel::CURRENT_TIMESTAMP
            )
            flash["notice"] = "Email verified successfully!"
          else
            flash["error"] = "Invalid or expired verification link"
          end
          r.redirect("/")
        end
      end
    end
  end
end

================
File: routes/interpretations.rb
================
module InterpretationsRoutes
  def self.load(r)
    r.on "interpretations" do
      # Index route for interpretations (if needed)
      r.is do
        r.get do
          @interpretations = Interpretation.order(Sequel.desc(:created_at))
          view("interpretations/index")
        end
      end

      # Show, Edit, Delete routes for specific interpretation
      r.on Integer do |interp_id|
        @interp = Interpretation[interp_id] or r.halt(404, "Interpretation not found")

        # GET /interpretations/:id
        r.is do
          r.get do
            view("interpretations/show")
          end

          # POST /interpretations/:id (Voting)
          r.post do
            require_login!
            
            vote_type = r.params["vote_type"]
            allowed_votes = ['upvote', 'downvote', 'inappropriate']

            unless allowed_votes.include?(vote_type)
              flash["error"] = "Invalid vote type."
              return r.redirect("/interpretations/#{interp_id}")
            end

            begin
              DB.transaction do
                existing_vote = InterpretationVote.where(
                  user_id: current_user.id,
                  interpretation_id: @interp.id
                ).first

                if existing_vote
                  existing_vote.update(vote_type: vote_type)
                else
                  InterpretationVote.create(
                    user_id: current_user.id,
                    interpretation_id: @interp.id,
                    vote_type: vote_type
                  )
                end
              end
              
              flash["notice"] = "Your vote has been recorded."
            rescue Sequel::Error => e
              flash["error"] = "Error recording vote. Please try again."
              logger.error "Vote error for interpretation #{@interp.id}: #{e.message}"
            end

            r.redirect("/interpretations/#{interp_id}")
          end
        end

        # Edit routes
        r.on "edit" do
          require_login!
          unless current_user.id == @interp.user_id || current_user.is_admin
            flash["error"] = "Not authorized to edit this interpretation"
            return r.redirect("/interpretations/#{interp_id}")
          end

          r.get do
            view("interpretations/edit")
          end

          r.post do
            if r.params["youtube_url"].to_s.strip.empty?
              flash["error"] = "YouTube URL is required"
              return view("interpretations/edit")
            end

            begin
              @interp.update(
                youtube_url: r.params["youtube_url"].strip,
                description: r.params["description"].to_s.strip
              )
              flash["notice"] = "Interpretation updated successfully"
              r.redirect("/interpretations/#{interp_id}")
            rescue Sequel::ValidationError => e
              flash["error"] = e.message
              view("interpretations/edit")
            end
          end
        end

        # Delete routes
        r.on "delete" do
          require_login!
          unless current_user.id == @interp.user_id || current_user.is_admin
            flash["error"] = "Not authorized to delete this interpretation"
            return r.redirect("/interpretations/#{interp_id}")
          end

          r.post do
            begin
              DB.transaction do
                @interp.interpretation_votes_dataset.delete  # Delete associated votes
                @interp.delete                              # Delete the interpretation
              end
              flash["notice"] = "Interpretation deleted successfully"
              r.redirect("/plays")
            rescue => e
              flash["error"] = "Error deleting interpretation"
              logger.error "Delete error for interpretation #{@interp.id}: #{e.message}"
              r.redirect("/interpretations/#{interp_id}")
            end
          end
        end
      end

      # Create new interpretation
      r.on "new" do
        require_login!

        line_id = r.params["line_id"]
        @speech_line = SpeechLine[line_id] or r.halt(404, "Line not found")

        r.get do
          view("interpretations/new")
        end

        r.post do
          youtube_url = r.params["youtube_url"].to_s.strip
          description = r.params["description"].to_s.strip

          if youtube_url.empty?
            flash["error"] = "YouTube URL is required"
            return r.redirect("/interpretations/new?line_id=#{line_id}")
          end

          begin
            interp = Interpretation.create(
              user_id: current_user.id,
              speech_line_id: @speech_line.id,
              youtube_url: youtube_url,
              description: description
            )
            
            # Check if user earned any achievements
            Achievement.check_achievements_for(current_user)
            
            flash["notice"] = "ASL interpretation submitted successfully!"
            r.redirect("/interpretations/#{interp.id}")
          rescue Sequel::ValidationError => e
            flash["error"] = e.message
            r.redirect("/interpretations/new?line_id=#{line_id}")
          rescue => e
            flash["error"] = "Error creating interpretation"
            logger.error "Create error: #{e.message}"
            r.redirect("/interpretations/new?line_id=#{line_id}")
          end
        end
      end
    end
  end
end

================
File: routes/plays.rb
================
module PlaysRoutes
  def self.load(r)
    r.hash_branch "plays" do |r|
      # List all plays (GET /plays)
      r.is do
        begin
          @plays = Play.order(:title).all
          view("plays/index")
        rescue Sequel::Error => e
          logger.error "Database error in plays index: #{e.message}"
          flash["error"] = "Unable to load plays"
          r.redirect("/")
        end
      end

      # Routes for individual play
      r.on Integer do |play_id|
        # Load play or halt with 404
        begin
          @play = Play[play_id] or r.halt(404, "Play not found")
        rescue Sequel::Error => e
          logger.error "Database error loading play #{play_id}: #{e.message}"
          r.halt(500, "Error loading play")
        end

        # Show play details (GET /plays/:play_id)
        r.is do
          begin
            @acts = @play.acts_dataset.order(:act_number).all
            view("plays/show_play")
          rescue Sequel::Error => e
            logger.error "Error loading acts for play #{play_id}: #{e.message}"
            flash["error"] = "Unable to load play details"
            r.redirect("/plays")
          end
        end

        # Routes for acts within a play
        r.on "acts", Integer do |act_id|
          begin
            @act = @play.acts_dataset[act_id: act_id] or r.halt(404, "Act not found")
          rescue Sequel::Error => e
            logger.error "Error loading act #{act_id}: #{e.message}"
            r.halt(500, "Error loading act")
          end

          # Routes for scenes within an act
          r.on "scenes", Integer do |scene_id|
            begin
              @scene = @act.scenes_dataset[scene_id: scene_id] or r.halt(404, "Scene not found")
            rescue Sequel::Error => e
              logger.error "Error loading scene #{scene_id}: #{e.message}"
              r.halt(500, "Error loading scene")
            end

            # Show scene details (GET /plays/:play_id/acts/:act_id/scenes/:scene_id)
            r.is do
              begin
                @speeches = @scene.speeches_dataset.order(:order_in_scene).all
                view("plays/show_scene")
              rescue Sequel::Error => e
                logger.error "Error loading speeches for scene #{scene_id}: #{e.message}"
                flash["error"] = "Unable to load scene details"
                r.redirect("/plays/#{play_id}/acts/#{act_id}")
              end
            end

            # Routes for speeches within a scene
            r.on "speeches", Integer do |speech_id|
              begin
                @speech = @scene.speeches_dataset[speech_id: speech_id] or r.halt(404, "Speech not found")
              rescue Sequel::Error => e
                logger.error "Error loading speech #{speech_id}: #{e.message}"
                r.halt(500, "Error loading speech")
              end

              # Show speech details (GET /plays/:play_id/acts/:act_id/scenes/:scene_id/speeches/:speech_id)
              r.is do
                begin
                  @lines = @speech.speech_lines_dataset.order(:start_line_number).all
                  @interpretations_by_line = @lines.each_with_object({}) do |line, hash|
                    hash[line.id] = line.interpretations_dataset.eager(:user).all
                  end
                  view("plays/show_speech")
                rescue Sequel::Error => e
                  logger.error "Error loading lines for speech #{speech_id}: #{e.message}"
                  flash["error"] = "Unable to load speech details"
                  r.redirect("/plays/#{play_id}/acts/#{act_id}/scenes/#{scene_id}")
                end
              end
            end
          end
        end
      end
    end
  end
end

================
File: routes/profiles.rb
================
module ProfilesRoutes
    def self.load(r)
      r.on "profiles", String do |username|
        @user = User.first(display_name: username) or r.halt(404, "User not found")
        
        # GET /profiles/:username
        r.get do
          @interpretations = @user.interpretations_dataset.order(Sequel.desc(:created_at))
          @achievements = @user.achievements
          view("profiles/show")
        end
      end
    end
  end

================
File: routes/search.rb
================
module SearchRoutes
  def self.load(r)
    r.on "search" do
      r.get do
        query = r.params["query"]
        category = r.params["category"]

        # Validate presence of query and category
        if query.nil? || query.strip.empty? || category.nil?
          flash["error"] = "Please enter a search query and select a category."
          r.redirect("/")
        end

        # Validate category
        valid_categories = ["plays", "lines", "interpretations"]
        unless valid_categories.include?(category)
          flash["error"] = "Invalid search category."
          r.redirect("/")
        end

        @query = query.strip
        @category = category

        case category
        when "plays"
          # Search by title or author (case-insensitive partial match)
          dataset = Play.where(Sequel.ilike(:title, "%#{@query}%") | Sequel.ilike(:author, "%#{@query}%"))
        when "lines"
          # Search by text (case-insensitive partial match) or by line number
          if @query =~ /^\d+$/
            # If query is purely numeric, search by line number
            line_number = @query.to_i
            dataset = SpeechLine.where(Sequel.|({ start_line_number: line_number }, { end_line_number: line_number }))
          else
            # Search by text
            dataset = SpeechLine.where(Sequel.ilike(:text, "%#{@query}%"))
          end
        when "interpretations"
          # Search by description or YouTube URL (case-insensitive partial match)
          dataset = Interpretation.where(Sequel.ilike(:description, "%#{@query}%") | Sequel.ilike(:youtube_url, "%#{@query}%"))
        end

        # Implement Pagy pagination
        @pagy, @results = pagy(dataset.order(:id), items: 10) # Adjust `items` as needed

        view("search/results")
      end
    end
  end
end

================
File: views/admin/plays/index.erb
================
<h2>Manage Plays</h2>
<%= csrf_tag %>
<a href="/admin/plays/new">Create New Play</a>
<table>
  <thead>
    <tr>
      <th>ID</th>
      <th>Title</th>
      <th>Author</th>
      <th>Actions</th>
    </tr>
  </thead>
  <tbody>
    <% @plays.each do |play| %>
      <tr>
        <td><%= play.id %></td>
        <td><%= play.title %></td>
        <td><%= play.author %></td>
        <td>
          <a href="/admin/plays/<%= play.id %>">View</a> |
          <a href="/admin/plays/<%= play.id %>/edit">Edit</a> |
          <form method="POST" action="/admin/plays/<%= play.id %>/delete" style="display:inline;">
            <%= csrf_tag %>
            <button type="submit" onclick="return confirm('Are you sure you want to delete this play?');">Delete</button>
          </form>
        </td>
      </tr>
    <% end %>
  </tbody>
</table>

================
File: views/admin/index.erb
================
<h2>Admin Area</h2>
<%= csrf_tag %>
<h3>All Users</h3>
<ul>
<% @all_users.each do |u| %>
  <li><%= u.id %> - <%= u.email %> (<%= u.display_name %>) <%= "(admin)" if u.is_admin %></li>
<% end %>
</ul>

<h3>All Interpretations</h3>
<ul>
<% @all_interps.each do |i| %>
  <li>
    ID: <%= i.id %>
    by: <%= i.user.display_name || i.user.email %> 
    on line ID <%= i.speech_line_id %> 
    (<%= i.youtube_url %>)
    <br/>
    votes: <%= i.interpretation_votes.count %>
  </li>
<% end %>
</ul>

================
File: views/auth/login.erb
================
<h2>Login</h2>
<form method="POST" action="">
  <%= csrf_tag %>
  <label>Email: <input type="email" name="email"/></label>
  <br/>
  <label>Password: <input type="password" name="password"/></label>
  <br/>
  <button type="submit">Login</button>
</form>

================
File: views/auth/register.erb
================
<h2>Register</h2>
<form method="POST" action="">
  <%= csrf_tag %>
  <label>Email: <input type="email" name="email"/></label>
  <br/>
  <label>Display Name: <input type="text" name="display_name"/></label>
  <br/>
  <label>Password: <input type="password" name="password"/></label>
  <br/>
  <button type="submit">Register</button>
</form>

================
File: views/interpretations/_video_preview.erb
================
<div class="video-preview" role="region" aria-label="ASL Interpretation Video">
  <% if @interpretation&.youtube_embed_url %>
    <iframe 
      src="<%= @interpretation.youtube_embed_url %>"
      title="ASL interpretation by <%= @interpretation.user.display_name %>"
      frameborder="0"
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
      allowfullscreen
      class="w-full aspect-video"
      loading="lazy">
    </iframe>
  <% else %>
    <p class="text-gray-500" role="status">No video available</p>
  <% end %>
</div>

================
File: views/interpretations/new.erb
================
<h2>New ASL Interpretation</h2>
<%= csrf_tag %>
<form method="POST" action="">
  <label>YouTube URL:
    <input type="text" name="youtube_url">
  </label>
  <br/>
  <label>Optional description/notes:
    <textarea name="description"></textarea>
  </label>
  <br/>
  <button type="submit">Submit</button>
</form>

================
File: views/interpretations/show.erb
================
<h2>Interpretation by <%= @interp.user.display_name || @interp.user.email %></h2>
<%= csrf_tag %>
<p>
  YouTube Link: <a href="<%= @interp.youtube_url %>" target="_blank"><%= @interp.youtube_url %></a><br/>
  Description: <%= @interp.description %><br/>
  Average Rating: <%= @interp.average_rating %>
</p>

<!-- Voting Form -->
<form method="POST" action="">
  <p>Vote on this interpretation:</p>
  <label>
    <input type="radio" name="vote_type" value="upvote" /> Upvote
  </label><br/>
  <label>
    <input type="radio" name="vote_type" value="downvote" /> Downvote
  </label><br/>
  <label>
    <input type="radio" name="vote_type" value="inappropriate" /> Inappropriate
  </label><br/>
  <button type="submit">Submit Vote</button>
</form>

================
File: views/plays/index.erb
================
<h2>Plays</h2>
<%= csrf_tag %>
<ul>
<% @plays.each do |play| %>
  <li>
    <a href="/plays/<%= play.id %>"><%= play.title %></a>
    <% if play.author %>(by <%= play.author %>)<% end %>
  </li>
<% end %>
</ul>

================
File: views/plays/show_play.erb
================
<h2><%= @play.title %></h2>
<%= csrf_tag %>
<p>Acts in this play:</p>
<ul>
<% @acts.each do |act| %>
  <li>
    <a href="/plays/<%= @play.id %>/acts/<%= act.id %>">
      Act <%= act.act_number %> (<%= act.description %>)
    </a>
  </li>
<% end %>
</ul>

================
File: views/plays/show_scene.erb
================
<h2><%= @scene.description %></h2>
<%= csrf_tag %>
<p>Speeches:</p>
<ul>
<% @speeches.each do |s| %>
  <li>
    <a href="/plays/<%= @play.id %>/acts/<%= @act.id %>/scenes/<%= @scene.id %>/speeches/<%= s.id %>">
      <%= s.speaker_name %> (order <%= s.order_in_scene %>)
    </a>
  </li>
<% end %>
</ul>

================
File: views/plays/show_speech.erb
================
<h2>Speech by <%= @speech.speaker_name %></h2>
<%= csrf_tag %>
<ul>
<% @lines.each do |line| %>
  <li>
    [Line <%= line.start_line_number %> to <%= line.end_line_number %>]:
    <%= line.text %>
    <br/>
    <a href="/interpretations/new?line_id=<%= line.id %>">Add ASL interpretation</a>
    <br/>
    <strong>ASL Interpretations:</strong>
    <ul>
      <% line.interpretations.each do |interp| %>
        <li>
          <a href="/interpretations/<%= interp.id %>">
            <%= interp.youtube_url %>
          </a>
          by <%= interp.user.display_name || interp.user.email %>
        </li>
      <% end %>
    </ul>
  </li>
<% end %>
</ul>

================
File: views/profiles/show.erb
================
<div class="user-profile" role="main" aria-labelledby="profile-title">
  <h1 id="profile-title"><%= @user.display_name %>'s Profile</h1>
  
  <section class="achievements" aria-labelledby="achievements-title">
    <h2 id="achievements-title">Achievements</h2>
    <div class="badges-grid" role="list">
      <% @achievements.each do |achievement| %>
        <div class="badge" role="listitem">
          <i class="<%= achievement.badge_icon %>" aria-hidden="true"></i>
          <h3><%= achievement.name %></h3>
          <p><%= achievement.description %></p>
          <time datetime="<%= achievement.earned_at.iso8601 %>">
            Earned <%= achievement.earned_at.strftime("%B %d, %Y") %>
          </time>
        </div>
      <% end %>
    </div>
  </section>

  <section class="interpretations" aria-labelledby="interpretations-title">
    <h2 id="interpretations-title">ASL Interpretations</h2>
    <div class="interpretations-grid" role="list">
      <% @interpretations.each do |interp| %>
        <article class="interpretation-card" role="listitem">
          <h3>
            From <%= interp.speech_line.speech.scene.act.play.title %>
            (Act <%= interp.speech_line.speech.scene.act.act_number %>,
             Scene <%= interp.speech_line.speech.scene.scene_number %>)
          </h3>
          <div class="video-preview">
            <%= render_partial("interpretations/_video_preview", interpretation: interp) %>
          </div>
          <div class="interpretation-stats">
            <span><%= interp.interpretation_votes.count { |v| v.vote_type == 'upvote' } %> upvotes</span>
            <time datetime="<%= interp.created_at.iso8601 %>">
              Posted <%= interp.created_at.strftime("%B %d, %Y") %>
            </time>
          </div>
        </article>
      <% end %>
    </div>
  </section>
</div>

================
File: views/search/results.erb
================
<h2>Search Results for "<%= ERB::Util.html_escape(@query) %>" in <%= @category.capitalize %></h2>
<%= csrf_tag %>
<% if @results.empty? %>
  <p>No results found.</p>
<% else %>
  <% case @category %>
  <% when "plays" %>
    <ul>
      <% @results.each do |play| %>
        <li>
          <a href="/plays/<%= play.id %>"><%= highlight(play.title, @query) %></a>
          <% if play.author %>(by <%= highlight(play.author, @query) %>)<% end %>
        </li>
      <% end %>
    </ul>
  <% when "lines" %>
    <ul>
      <% @results.each do |line| %>
        <li>
          <strong>Line <%= line.start_line_number %> to <%= line.end_line_number %>:</strong>
          <%= highlight(line.text, @query) %>
          <br/>
          <a href="/interpretations/new?line_id=<%= line.id %>">Add ASL interpretation</a>
        </li>
      <% end %>
    </ul>
  <% when "interpretations" %>
    <ul>
      <% @results.each do |interp| %>
        <li>
          <a href="/interpretations/<%= interp.id %>">
            Interpretation by <%= interp.user.display_name || interp.user.email %>
          </a>
          <br/>
          YouTube URL: <a href="<%= interp.youtube_url %>" target="_blank"><%= interp.youtube_url %></a>
          <br/>
          Description: <%= highlight(interp.description, @query) %>
        </li>
      <% end %>
    </ul>
  <% end %>

  <!-- Pagy Navigation -->
  <div class="pagy-nav">
    <%= pagy_nav(@pagy) %>
  </div>
<% end %>

================
File: views/index.erb
================
<h2>Welcome!</h2>
<%= csrf_tag %>
<p>This is a place to browse Shakespeare’s lines and attach ASL YouTube videos.</p>
<p>Currently focusing on Titus Andronicus.</p>

================
File: views/layout.erb
================
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8"/>
    <title>Shakespeare ASL</title>
    <%= assets(:css) %>
  </head>
  <main id="main-content" role="main">
  <%= breadcrumb_trail %>
  <% if flash["error"] %>
    <div role="alert" class="error-message">
      <%= flash["error"] %>
    </div>
  <% end %>
  <% if flash["notice"] %>
    <div role="status" class="notice-message">
      <%= flash["notice"] %>
    </div>
  <% end %>
  <%= yield %>
  </main>
  <body>
    <header>
      <h1>Shakespeare ASL Interpretations</h1>
      <nav>
        <a href="/">Home</a>
        <a href="/plays">Plays</a>
        <% if @current_user %>
          <a href="/auth/logout">Logout (@<%= @current_user.display_name || @current_user.email %>)</a>
          <% if @current_user.is_admin %>
            <a href="/admin">Admin</a>
          <% end %>
        <% else %>
          <a href="/auth/login">Login</a>
          <a href="/auth/register">Register</a>
        <% end %>
        <!-- Search Form -->
        <form action="/search" method="GET" style="display:inline; margin-left:20px;">
          <input type="text" name="query" placeholder="Search..." required/>
          <select name="category">
            <option value="plays">Plays</option>
            <option value="lines">Speech Lines</option>
            <option value="interpretations">Interpretations</option>
          </select>
          <button type="submit">Search</button>
        </form>
      </nav>
    </header>

    <% if flash["error"] %>
      <div style="color:red;"><%= flash["error"] %></div>
    <% end %>
    <% if flash["notice"] %>
      <div style="color:green;"><%= flash["notice"] %></div>
    <% end %>

    <%= yield %>

    <footer>
      <hr/>
      <p>&copy; <%= Time.now.year %> Shakespeare ASL App</p>
    </footer>
    <%= assets(:js) %>
  </body>
</html>

================
File: config.ru
================
require_relative "shakespeare_app"
run ShakespeareApp.freeze.app

================
File: db.rb
================
require "sequel"

DB = Sequel.connect(ENV.fetch("DATABASE_URL") {
  "postgres://localhost:5432/shakespeare_app_development"
})

# Optional: any DB-specific config, e.g.:
DB.extension :pg_json
DB.extension :pg_enum
DB.loggers << Logger.new($stdout) unless ENV["RACK_ENV"] == "test"

================
File: Gemfile
================
gem "rack", "~> 3.1"

gem "pg", "~> 1.5"

gem "bcrypt", "~> 3.1"

gem "roda", "~> 3.88"

gem "pagy", "~> 9.3"

================
File: Gemfile.lock
================
GEM
  specs:
    bcrypt (3.1.20)
    pagy (9.3.3)
    pg (1.5.9)
    rack (3.1.8)
    roda (3.88.0)
      rack

PLATFORMS
  arm64-darwin-24
  ruby

DEPENDENCIES
  bcrypt (~> 3.1)
  pagy (~> 9.3)
  pg (~> 1.5)
  rack (~> 3.1)
  roda (~> 3.88)

BUNDLED WITH
   2.6.3

================
File: models.rb
================
require_relative "db"
require "sequel"
require "bcrypt"

# Sequel model classes

class User < Sequel::Model
  plugin :timestamps, update_on_create: true
  plugin :validation_helpers

  one_to_many :interpretations
  one_to_many :interpretation_votes

  def validate
    super
    validates_presence [:email, :password_digest]
    validates_unique :email
    validates_format /\A[^@\s]+@[^@\s]+\z/, :email, message: 'must be a valid email address'
  end

  def total_upvotes_received
    interpretations_dataset.map do |interp|
      interp.interpretation_votes.count { |vote| vote.vote_type == 'upvote' }
    end.sum
  end

  def recent_activity(limit = 10)
    interpretations_dataset
      .order(Sequel.desc(:created_at))
      .limit(limit)
  end

  def has_voted_on?(interpretation)
    interpretation_votes_dataset
      .where(interpretation_id: interpretation.id)
      .count > 0
  end

  def vote_type_for(interpretation)
    vote = interpretation_votes_dataset
      .where(interpretation_id: interpretation.id)
      .first
    vote&.vote_type
  end

  # For password encryption using bcrypt:
  def password=(new_password)
    self.password_digest = BCrypt::Password.create(new_password)
  end

  def valid_password?(attempt)
    return false if password_digest.nil?
    BCrypt::Password.new(password_digest) == attempt
  end
end

class Achievement < Sequel::Model
  one_to_many :user_achievements
  many_to_many :users, join_table: :user_achievements

  BADGES = {
    first_interpretation: {
      name: "First ASL",
      description: "Posted your first ASL interpretation",
      badge_icon: "badge-first-post"
    },
    interpretation_star: {
      name: "Interpretation Star",
      description: "Posted 10 interpretations",
      badge_icon: "badge-star"
    },
    community_favorite: {
      name: "Community Favorite",
      description: "Received 100 upvotes across all interpretations",
      badge_icon: "badge-favorite"
    },
    shakespeare_scholar: {
      name: "Shakespeare Scholar",
      description: "Posted interpretations from 5 different plays",
      badge_icon: "badge-scholar"
    }
  }

  def self.check_achievements_for(user)
    # Check First Interpretation
    if user.interpretations.count == 1
      award_achievement(user, :first_interpretation)
    end

    # Check Interpretation Star
    if user.interpretations.count >= 10
      award_achievement(user, :interpretation_star)
    end

    # Check Community Favorite
    total_upvotes = user.interpretations.sum { |i| i.interpretation_votes.count { |v| v.vote_type == 'upvote' } }
    if total_upvotes >= 100
      award_achievement(user, :community_favorite)
    end

    # Check Shakespeare Scholar
    unique_plays = user.interpretations.map { |i| i.speech_line.speech.scene.act.play }.uniq
    if unique_plays.length >= 5
      award_achievement(user, :shakespeare_scholar)
    end
  end

  private

  def self.award_achievement(user, badge_key)
    badge = BADGES[badge_key]
    achievement = Achievement.find_or_create(name: badge[:name]) do |a|
      a.description = badge[:description]
      a.badge_icon = badge[:badge_icon]
    end
    
    unless UserAchievement.where(user_id: user.id, achievement_id: achievement.id).any?
      UserAchievement.create(user_id: user.id, achievement_id: achievement.id)
    end
  end
end

class UserAchievement < Sequel::Model
  many_to_one :user
  many_to_one :achievement
end

class Play < Sequel::Model
  plugin :timestamps, update_on_create: true
  one_to_many :acts

  # Scope for searching plays
  def self.search(query)
    where(Sequel.ilike(:title, "%#{query}%") | Sequel.ilike(:author, "%#{query}%"))
  end

  def validate
    super
    validates_presence [:title]
    validates_unique :title
  end
end

class Act < Sequel::Model
  plugin :timestamps, update_on_create: true
  many_to_one :play
  one_to_many :scenes
end

class Scene < Sequel::Model
  plugin :timestamps, update_on_create: true
  many_to_one :act
  one_to_many :speeches
end

class Speech < Sequel::Model
  plugin :timestamps, update_on_create: true
  many_to_one :scene
  one_to_many :speech_lines
end

class SpeechLine < Sequel::Model
  plugin :timestamps, update_on_create: true
  many_to_one :speech
  one_to_many :interpretations

  def validate
    super
    validates_presence [:speech_id, :text]
  end
end

class Interpretation < Sequel::Model
  plugin :timestamps, update_on_create: true
  many_to_one :user
  many_to_one :speech_line
  one_to_many :interpretation_votes

  def average_rating
    votes = interpretation_votes_dataset
    total = votes.where(vote_type: 'upvote').count - votes.where(vote_type: 'downvote').count
    count = votes.where(vote_type: ['upvote', 'downvote']).count
    return 0 if count.zero?
    (total.to_f / count).round(2)
  end

  def youtube_video_id
    return nil unless youtube_url
    regex = %r{(?:youtube(?:-nocookie)?\.com/(?:[^/\n\s]+/\S+/|(?:v|e(?:mbed)?)/|\S*?[?&]v=)|youtu\.be/)([a-zA-Z0-9_-]{11})}
    matches = regex.match(youtube_url)
    matches[1] if matches
  end

  def validate
    super
    validates_presence [:youtube_url]
    validates_format(
      %r{^https?://(?:www\.)?(?:youtube\.com/watch\?v=|youtu\.be/)[a-zA-Z0-9_-]{11}(?:&\S*)?$}, 
      :youtube_url, 
      message: 'must be a valid YouTube URL'
    )
  end

  def voted_by?(user)
    return false unless user
    interpretation_votes_dataset
      .where(user_id: user.id)
      .count > 0
  end

  def vote_type_by(user)
    return nil unless user
    vote = interpretation_votes_dataset
      .where(user_id: user.id)
      .first
    vote&.vote_type
  end
end

class InterpretationVote < Sequel::Model
  plugin :timestamps, update_on_create: true
  many_to_one :user
  many_to_one :interpretation

  def validate
    super
    validates_presence [:user_id, :interpretation_id, :vote_type]
    validates_includes ['upvote', 'downvote', 'inappropriate'], :vote_type
    validates_unique [:user_id, :interpretation_id], message: 'has already voted for this interpretation'
  end
end

================
File: pagy.rb
================
# frozen_string_literal: true

# Pagy initializer file (9.3.3)
# Customize only what you really need and notice that the core Pagy works also without any of the following lines.
# Should you just cherry pick part of this file, please maintain the require-order of the extras


# Pagy Variables
# See https://ddnexus.github.io/pagy/docs/api/pagy#variables
# You can set any pagy variable as a Pagy::DEFAULT. They can also be overridden per instance by just passing them to
# Pagy.new|Pagy::Countless.new|Pagy::Calendar::*.new or any of the #pagy* controller methods
# Here are the few that make more sense as DEFAULTs:
# Pagy::DEFAULT[:limit]       = 20                    # default
# Pagy::DEFAULT[:size]        = 7                     # default
# Pagy::DEFAULT[:ends]        = true                  # default
# Pagy::DEFAULT[:page_param]  = :page                 # default
# Pagy::DEFAULT[:count_args]  = []                    # example for non AR ORMs
# Pagy::DEFAULT[:max_pages]   = 3000                  # example


# Extras
# See https://ddnexus.github.io/pagy/categories/extra


# Legacy Compatibility Extras

# Size extra: Enable the Array type for the `:size` variable (e.g. `size: [1,4,4,1]`)
# See https://ddnexus.github.io/pagy/docs/extras/size
# require 'pagy/extras/size'   # must be required before the other extras


# Backend Extras

# Arel extra: For better performance utilizing grouped ActiveRecord collections:
# See: https://ddnexus.github.io/pagy/docs/extras/arel
# require 'pagy/extras/arel'

# Array extra: Paginate arrays efficiently, avoiding expensive array-wrapping and without overriding
# See https://ddnexus.github.io/pagy/docs/extras/array
# require 'pagy/extras/array'

# Calendar extra: Add pagination filtering by calendar time unit (year, quarter, month, week, day)
# See https://ddnexus.github.io/pagy/docs/extras/calendar
# require 'pagy/extras/calendar'
# Default for each calendar unit class in IRB:
# >> Pagy::Calendar::Year::DEFAULT
# >> Pagy::Calendar::Quarter::DEFAULT
# >> Pagy::Calendar::Month::DEFAULT
# >> Pagy::Calendar::Week::DEFAULT
# >> Pagy::Calendar::Day::DEFAULT
#
# Uncomment the following lines, if you need calendar localization without using the I18n extra
# module LocalizePagyCalendar
#   def localize(time, opts)
#     ::I18n.l(time, **opts)
#   end
# end
# Pagy::Calendar.prepend LocalizePagyCalendar

# Countless extra: Paginate without any count, saving one query per rendering
# See https://ddnexus.github.io/pagy/docs/extras/countless
# require 'pagy/extras/countless'
# Pagy::DEFAULT[:countless_minimal] = false   # default (eager loading)

# Elasticsearch Rails extra: Paginate `ElasticsearchRails::Results` objects
# See https://ddnexus.github.io/pagy/docs/extras/elasticsearch_rails
# Default :pagy_search method: change only if you use also
# the searchkick or meilisearch extra that defines the same
# Pagy::DEFAULT[:elasticsearch_rails_pagy_search] = :pagy_search
# Default original :search method called internally to do the actual search
# Pagy::DEFAULT[:elasticsearch_rails_search] = :search
# require 'pagy/extras/elasticsearch_rails'

# Headers extra: http response headers (and other helpers) useful for API pagination
# See https://ddnexus.github.io/pagy/docs/extras/headers
# require 'pagy/extras/headers'
# Pagy::DEFAULT[:headers] = { page: 'Current-Page',
#                            limit: 'Page-Items',
#                            count: 'Total-Count',
#                            pages: 'Total-Pages' }     # default

# Keyset extra: Paginate with the Pagy keyset pagination technique
# See https://ddnexus.github.io/pagy/docs/extras/keyset
# require 'pagy/extras/keyset'

# Meilisearch extra: Paginate `Meilisearch` result objects
# See https://ddnexus.github.io/pagy/docs/extras/meilisearch
# Default :pagy_search method: change only if you use also
# the elasticsearch_rails or searchkick extra that define the same method
# Pagy::DEFAULT[:meilisearch_pagy_search] = :pagy_search
# Default original :search method called internally to do the actual search
# Pagy::DEFAULT[:meilisearch_search] = :ms_search
# require 'pagy/extras/meilisearch'

# Metadata extra: Provides the pagination metadata to Javascript frameworks like Vue.js, react.js, etc.
# See https://ddnexus.github.io/pagy/docs/extras/metadata
# you must require the JS Tools internal extra (BEFORE the metadata extra) ONLY if you need also the :sequels
# require 'pagy/extras/js_tools'
# require 'pagy/extras/metadata'
# For performance reasons, you should explicitly set ONLY the metadata you use in the frontend
# Pagy::DEFAULT[:metadata] = %i[scaffold_url page prev next last]   # example

# Searchkick extra: Paginate `Searchkick::Results` objects
# See https://ddnexus.github.io/pagy/docs/extras/searchkick
# Default :pagy_search method: change only if you use also
# the elasticsearch_rails or meilisearch extra that defines the same
# Pagy::DEFAULT[:searchkick_pagy_search] = :pagy_search
# Default original :search method called internally to do the actual search
# Pagy::DEFAULT[:searchkick_search] = :search
# require 'pagy/extras/searchkick'
# uncomment if you are going to use Searchkick.pagy_search
# Searchkick.extend Pagy::Searchkick


# Frontend Extras

# Bootstrap extra: Add nav, nav_js and combo_nav_js helpers and templates for Bootstrap pagination
# See https://ddnexus.github.io/pagy/docs/extras/bootstrap
# require 'pagy/extras/bootstrap'

# Bulma extra: Add nav, nav_js and combo_nav_js helpers and templates for Bulma pagination
# See https://ddnexus.github.io/pagy/docs/extras/bulma
# require 'pagy/extras/bulma'

# Pagy extra: Add the pagy styled versions of the javascript-powered navs
# and a few other components to the Pagy::Frontend module.
# See https://ddnexus.github.io/pagy/docs/extras/pagy
# require 'pagy/extras/pagy'

# Multi size var used by the *_nav_js helpers
# See https://ddnexus.github.io/pagy/docs/extras/pagy#steps
# Pagy::DEFAULT[:steps] = { 0 => 5, 540 => 7, 720 => 9 }   # example


# Feature Extras

# Gearbox extra: Automatically change the limit per page depending on the page number
# See https://ddnexus.github.io/pagy/docs/extras/gearbox
# require 'pagy/extras/gearbox'
# set to false only if you want to make :gearbox_extra an opt-in variable
# Pagy::DEFAULT[:gearbox_extra] = false               # default true
# Pagy::DEFAULT[:gearbox_limit] = [15, 30, 60, 100]   # default

# Limit extra: Allow the client to request a custom limit per page with an optional selector UI
# See https://ddnexus.github.io/pagy/docs/extras/limit
# require 'pagy/extras/limit'
# set to false only if you want to make :limit_extra an opt-in variable
# Pagy::DEFAULT[:limit_extra] = false    # default true
# Pagy::DEFAULT[:limit_param] = :limit   # default
# Pagy::DEFAULT[:limit_max]   = 100      # default

# Overflow extra: Allow for easy handling of overflowing pages
# See https://ddnexus.github.io/pagy/docs/extras/overflow
# require 'pagy/extras/overflow'
# Pagy::DEFAULT[:overflow] = :empty_page    # default  (other options: :last_page and :exception)

# Trim extra: Remove the page=1 param from links
# See https://ddnexus.github.io/pagy/docs/extras/trim
# require 'pagy/extras/trim'
# set to false only if you want to make :trim_extra an opt-in variable
# Pagy::DEFAULT[:trim_extra] = false # default true

# Standalone extra: Use pagy in non Rack environment/gem
# See https://ddnexus.github.io/pagy/docs/extras/standalone
# require 'pagy/extras/standalone'
# Pagy::DEFAULT[:url] = 'http://www.example.com/subdir'  # optional default

# Jsonapi extra: Implements JSON:API specifications
# See https://ddnexus.github.io/pagy/docs/extras/jsonapi
# require 'pagy/extras/jsonapi'   # must be required after the other extras
# set to false only if you want to make :jsonapi an opt-in variable
# Pagy::DEFAULT[:jsonapi] = false  # default true

# Rails
# Enable the .js file required by the helpers that use javascript
# (pagy*_nav_js, pagy*_combo_nav_js, and pagy_limit_selector_js)
# See https://ddnexus.github.io/pagy/docs/api/javascript

# With the asset pipeline
# Sprockets need to look into the pagy javascripts dir, so add it to the assets paths
# Rails.application.config.assets.paths << Pagy.root.join('javascripts')

# I18n

# Pagy internal I18n: ~18x faster using ~10x less memory than the i18n gem
# See https://ddnexus.github.io/pagy/docs/api/i18n
# Notice: No need to configure anything in this section if your app uses only "en"
# or if you use the i18n extra below
#
# Examples:
# load the "de" built-in locale:
# Pagy::I18n.load(locale: 'de')
#
# load the "de" locale defined in the custom file at :filepath:
# Pagy::I18n.load(locale: 'de', filepath: 'path/to/pagy-de.yml')
#
# load the "de", "en" and "es" built-in locales:
# (the first passed :locale will be used also as the default_locale)
# Pagy::I18n.load({ locale: 'de' },
#                 { locale: 'en' },
#                 { locale: 'es' })
#
# load the "en" built-in locale, a custom "es" locale,
# and a totally custom locale complete with a custom :pluralize proc:
# (the first passed :locale will be used also as the default_locale)
# Pagy::I18n.load({ locale: 'en' },
#                 { locale: 'es', filepath: 'path/to/pagy-es.yml' },
#                 { locale: 'xyz',  # not built-in
#                   filepath: 'path/to/pagy-xyz.yml',
#                   pluralize: lambda{ |count| ... } )


# I18n extra: uses the standard i18n gem which is ~18x slower using ~10x more memory
# than the default pagy internal i18n (see above)
# See https://ddnexus.github.io/pagy/docs/extras/i18n
# require 'pagy/extras/i18n'


# When you are done setting your own default freeze it, so it will not get changed accidentally
Pagy::DEFAULT.freeze

================
File: Rakefile
================
require_relative "db"
require "rake"
require "sequel"

namespace :db do
  desc "Migrate the database (use VERSION=n to rollback)"
  task :migrate do
    Sequel.extension :migration
    Sequel::Migrator.run(DB, "migrate", :use_transactions=>true)
    puts "Database migrated!"
  end

  desc "Roll back the latest migration"
  task :rollback do
    Sequel.extension :migration
    Sequel::Migrator.run(DB, "migrate", :target => (DB[:schema_info].get(:version) - 1))
    puts "Rolled back one step!"
  end
end

desc "Run all tests (placeholder task)"
task :default => ["test"]

desc "Test Task (placeholder)"
task :test do
  puts "No tests yet."
end

================
File: shakespeare_app.rb
================
require "bundler/setup"
require "roda"
require_relative "models"
require_relative "helpers/highlight_helper"
require_relative "pagy"

# Require route modules
require_relative "routes/admin"
require_relative "routes/auth"
require_relative "routes/interpretations"
require_relative "routes/plays"
require_relative "routes/search"

class ShakespeareApp < Roda
  # Middleware for sessions
  use Rack::Session::Cookie, secret: ENV.fetch("SESSION_SECRET") { "dev_secret_please_change" }

  # Roda plugins
  plugin :render, layout: "layout", views: "views", escape: true
  plugin :hash_branches
  plugin :assets
  plugin :flash   # For flash messages
  plugin :public  # For serving files in /public if needed
  plugin :csrf, secret: ENV.fetch("CSRF_SECRET") { "another_dev_secret_please_change" }
  plugin :csrf_verify

  # Ensure forms include CSRF tokens
  def csrf_token
    request.csrf_token
  end

  def csrf_tag
    "<input type='hidden' name='csrf_token' value='#{csrf_token}' />"
  end

  # Include Pagy Backend and Frontend
  include Pagy::Backend
  include Pagy::Frontend

  # Basic request authentication helper
  route do |r|
    r.public
    r.assets

    # Make current user accessible
    @current_user = session[:user_id] ? User[session[:user_id]] : nil

    # Load route modules
    AdminRoutes.load(r)
    AuthRoutes.load(r)
    InterpretationsRoutes.load(r)
    PlaysRoutes.load(r)
    SearchRoutes.load(r)

    # Root route
    r.root do
      view("index")  # a simple welcome page
    end
  end

  # Utility methods accessible in routes
  def current_user
    @current_user
  end

  def require_login!
    unless current_user
      flash["error"] = "You must be logged in"
      r.redirect("/auth/login")
    end
  end

  def require_admin!
    unless current_user&.is_admin
      flash["error"] = "Admin access required"
      r.redirect("/")
    end
  end

  # Make highlight helper available in views
  def highlight(text, term)
    HighlightHelper.highlight(text, term)
  end
end
